/* File generated by: simse.codegenerator.stategenerator.ADTGenerator */
package simse.adts.actions;
import simse.adts.objects.*;
import simse.state.ArtifactStateRepository;
import simse.state.CustomerStateRepository;
import simse.state.EmployeeStateRepository;
import simse.state.ProjectStateRepository;
import simse.state.ToolStateRepository;
import java.util.*;
public class CustomerComplainsAction extends Action implements Cloneable
{
private Hashtable<Employee, Boolean> custreps;
private Hashtable<Project, Boolean> projs;
private int timeToLive;
public CustomerComplainsAction()
{
custreps = new Hashtable<Employee, Boolean>();
projs = new Hashtable<Project, Boolean>();
timeToLive = 50;
}

public Object clone() {
CustomerComplainsAction cl = (CustomerComplainsAction)(super.clone());
Hashtable<Employee, Boolean> clonedcustreps = new Hashtable<Employee, Boolean>();
clonedcustreps.putAll(custreps);
cl.custreps = clonedcustreps;
Hashtable<Project, Boolean> clonedprojs = new Hashtable<Project, Boolean>();
clonedprojs.putAll(projs);
cl.projs = clonedprojs;
return cl;
}

public int getTimeToLive()
{
return timeToLive;
}

public void decrementTimeToLive()
{
timeToLive--;
if(timeToLive < 0)
{
timeToLive = 0;
}
}

public Vector<SSObject> getAllParticipants()
{
Vector<SSObject> all = new Vector<SSObject>();
all.addAll(getAllCustReps());
all.addAll(getAllProjs());
return all;
}
public Vector<SSObject> getAllActiveParticipants()
{
Vector<SSObject> all = new Vector<SSObject>();
all.addAll(getAllActiveCustReps());
all.addAll(getAllActiveProjs());
return all;
}

public Vector<SSObject> getAllInactiveParticipants()
{
Vector<SSObject> all = new Vector<SSObject>();
all.addAll(getAllInactiveCustReps());
all.addAll(getAllInactiveProjs());
return all;
}
public Vector<Employee> getAllCustReps()
{
Vector<Employee>a = new Vector<Employee>();
Enumeration<Employee> e = custreps.keys();
for(int i=0; i<custreps.size(); i++)
{
a.add(e.nextElement());
}
return a;
}

public Vector<Employee> getAllActiveCustReps()
{
Vector<Employee> a = new Vector<Employee>();
Enumeration<Employee> e = custreps.keys();
for(int i=0; i<custreps.size(); i++)
{
Employee key = e.nextElement();
if((custreps.get(key)).booleanValue() == true)
{
a.add(key);
}
}
return a;
}

public Vector<Employee> getAllInactiveCustReps()
{
Vector<Employee> a = new Vector<Employee>();
Enumeration<Employee> e = custreps.keys();
for(int i=0; i<custreps.size(); i++)
{
Employee key = e.nextElement();
if((custreps.get(key)).booleanValue() == false)
{
a.add(key);
}
}
return a;
}

public boolean addCustRep(Employee a)
{
if((custreps.containsKey(a)) ||( ((a instanceof CustomerRep) == false)) || (custreps.size() >= 1))
{
return false;
}
else
{
custreps.put(a, new Boolean(true));
return true;
}
}

public boolean removeCustRep(Employee a)
{
if(custreps.containsKey(a))
{
custreps.remove(a);
return true;
}
return false;
}

public boolean setCustRepActive(Employee a)
{
if(custreps.containsKey(a))
{
custreps.put(a, new Boolean(true));
return true;
}
return false;
}

public boolean setCustRepInactive(Employee a)
{
if(custreps.containsKey(a))
{
custreps.put(a, new Boolean(false));
return true;
}
return false;
}
public Vector<Project> getAllProjs()
{
Vector<Project>a = new Vector<Project>();
Enumeration<Project> e = projs.keys();
for(int i=0; i<projs.size(); i++)
{
a.add(e.nextElement());
}
return a;
}

public Vector<Project> getAllActiveProjs()
{
Vector<Project> a = new Vector<Project>();
Enumeration<Project> e = projs.keys();
for(int i=0; i<projs.size(); i++)
{
Project key = e.nextElement();
if((projs.get(key)).booleanValue() == true)
{
a.add(key);
}
}
return a;
}

public Vector<Project> getAllInactiveProjs()
{
Vector<Project> a = new Vector<Project>();
Enumeration<Project> e = projs.keys();
for(int i=0; i<projs.size(); i++)
{
Project key = e.nextElement();
if((projs.get(key)).booleanValue() == false)
{
a.add(key);
}
}
return a;
}

public boolean addProj(Project a)
{
if((projs.containsKey(a)) ||( ((a instanceof TheProject) == false)) || (projs.size() >= 1))
{
return false;
}
else
{
projs.put(a, new Boolean(true));
return true;
}
}

public boolean removeProj(Project a)
{
if(projs.containsKey(a))
{
projs.remove(a);
return true;
}
return false;
}

public boolean setProjActive(Project a)
{
if(projs.containsKey(a))
{
projs.put(a, new Boolean(true));
return true;
}
return false;
}

public boolean setProjInactive(Project a)
{
if(projs.containsKey(a))
{
projs.put(a, new Boolean(false));
return true;
}
return false;
}
/*
* Replaces all the participants in this action with their equivalent objects
* in the current state. Calling this function solves the problem that happens
* when you clone actions -- their hashtables point to participant objects
* that were part of the previous, non-cloned state. Hence, this function
* should be called after this object is cloned.
*/
public void refetchParticipants(ArtifactStateRepository artifactRep, CustomerStateRepository customerRep, EmployeeStateRepository employeeRep, ProjectStateRepository projectRep, ToolStateRepository toolRep) {
// custrep participants:
Hashtable<Employee, Boolean> newCustReps = new Hashtable<Employee, Boolean>();
Iterator<Map.Entry<Employee, Boolean>> custrepsIterator = custreps.entrySet().iterator();
while (custrepsIterator.hasNext()) {
Map.Entry<Employee, Boolean> entry = custrepsIterator.next();
Employee oldCustRep = entry.getKey();
if (oldCustRep instanceof CustomerRep) {
Employee newCustRep = employeeRep.getCustomerRepStateRepository().get(((CustomerRep)oldCustRep).getName());
Boolean activeStatus = custreps.get(oldCustRep);
newCustReps.put(newCustRep, activeStatus);
}
}
custreps.clear();
custreps.putAll(newCustReps);

// proj participants:
Hashtable<Project, Boolean> newProjs = new Hashtable<Project, Boolean>();
Iterator<Map.Entry<Project, Boolean>> projsIterator = projs.entrySet().iterator();
while (projsIterator.hasNext()) {
Map.Entry<Project, Boolean> entry = projsIterator.next();
Project oldProj = entry.getKey();
if (oldProj instanceof TheProject) {
Project newProj = projectRep.getTheProjectStateRepository().get(((TheProject)oldProj).getName());
Boolean activeStatus = projs.get(oldProj);
newProjs.put(newProj, activeStatus);
}
}
projs.clear();
projs.putAll(newProjs);

}
}