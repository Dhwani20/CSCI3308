/* File generated by: simse.codegenerator.explanatorytoolgenerator.ActionGraphGenerator */
package simse.explanatorytool;

import simse.adts.actions.*;
import simse.SimSE;
import simse.state.Clock;
import simse.state.logger.Logger;
import simse.state.State;

import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartMouseEvent;
import org.jfree.chart.ChartMouseListener;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.ChartRenderingInfo;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.axis.ValueAxis;
import org.jfree.chart.entity.ChartEntity;
import org.jfree.chart.entity.XYItemEntity;
import org.jfree.chart.labels.AbstractXYItemLabelGenerator;
import org.jfree.chart.labels.XYToolTipGenerator;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.xy.XYLineAndShapeRenderer;
import org.jfree.data.Range;
import org.jfree.data.xy.XYDataset;
import org.jfree.data.xy.XYSeries;
import org.jfree.data.xy.XYSeriesCollection;
import org.jfree.ui.RectangleEdge;
import org.jfree.ui.RectangleInsets;
import org.jfree.ui.RefineryUtilities;

import java.awt.Color;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.Point;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.List;
import java.util.Vector;

import javax.swing.JFrame;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JSeparator;

public class ActionGraph extends JFrame implements ChartMouseListener, MouseListener, ActionListener {
private ArrayList<State> log;
private String[] actionNames;
private JFreeChart chart; // chart object
private ChartPanel chartPanel;
private JMenuItem newBranchItem;
private JSeparator separator;
private int lastRightClickedX; // last x-val that was right-clicked on
private XYSeriesCollection dataset;
private Branch branch; // branch from which this action graph is generated
private Hashtable<Integer, XYSeries> series = new Hashtable<Integer, XYSeries>(); // a Hashtable to map action ids to XYSeries
private ArrayList<String> indices = new ArrayList<String>(); // an ArrayList to map action indices to series names
private int actionIndex = 1; // counter for used action indices to be used for their y-values
private int createuserstoriesIndex = 1; // index to be used for labeling multiple actions of the same type
private ArrayList<Integer> createuserstoriesIndices = new ArrayList<Integer>(); // an ArrayList to map indices for CreateUserStories Action labels to action ids
private int releaseplanningmeetingIndex = 1; // index to be used for labeling multiple actions of the same type
private ArrayList<Integer> releaseplanningmeetingIndices = new ArrayList<Integer>(); // an ArrayList to map indices for ReleasePlanningMeeting Action labels to action ids
private int startiterationIndex = 1; // index to be used for labeling multiple actions of the same type
private ArrayList<Integer> startiterationIndices = new ArrayList<Integer>(); // an ArrayList to map indices for StartIteration Action labels to action ids
private int iterationplanningmeetingIndex = 1; // index to be used for labeling multiple actions of the same type
private ArrayList<Integer> iterationplanningmeetingIndices = new ArrayList<Integer>(); // an ArrayList to map indices for IterationPlanningMeeting Action labels to action ids
private int chooseuserstoriesforiterationIndex = 1; // index to be used for labeling multiple actions of the same type
private ArrayList<Integer> chooseuserstoriesforiterationIndices = new ArrayList<Integer>(); // an ArrayList to map indices for ChooseUserStoriesForIteration Action labels to action ids
private int createprogrammingtasksIndex = 1; // index to be used for labeling multiple actions of the same type
private ArrayList<Integer> createprogrammingtasksIndices = new ArrayList<Integer>(); // an ArrayList to map indices for CreateProgrammingTasks Action labels to action ids
private int createacceptancetestsIndex = 1; // index to be used for labeling multiple actions of the same type
private ArrayList<Integer> createacceptancetestsIndices = new ArrayList<Integer>(); // an ArrayList to map indices for CreateAcceptanceTests Action labels to action ids
private int designIndex = 1; // index to be used for labeling multiple actions of the same type
private ArrayList<Integer> designIndices = new ArrayList<Integer>(); // an ArrayList to map indices for Design Action labels to action ids
private int createunittestsIndex = 1; // index to be used for labeling multiple actions of the same type
private ArrayList<Integer> createunittestsIndices = new ArrayList<Integer>(); // an ArrayList to map indices for CreateUnitTests Action labels to action ids
private int learncodingstandardIndex = 1; // index to be used for labeling multiple actions of the same type
private ArrayList<Integer> learncodingstandardIndices = new ArrayList<Integer>(); // an ArrayList to map indices for LearnCodingStandard Action labels to action ids
private int programIndex = 1; // index to be used for labeling multiple actions of the same type
private ArrayList<Integer> programIndices = new ArrayList<Integer>(); // an ArrayList to map indices for Program Action labels to action ids
private int pairprogramrobertjoyceIndex = 1; // index to be used for labeling multiple actions of the same type
private ArrayList<Integer> pairprogramrobertjoyceIndices = new ArrayList<Integer>(); // an ArrayList to map indices for PairProgramRobertJoyce Action labels to action ids
private int pairprogramtimothyredaIndex = 1; // index to be used for labeling multiple actions of the same type
private ArrayList<Integer> pairprogramtimothyredaIndices = new ArrayList<Integer>(); // an ArrayList to map indices for PairProgramTimothyReda Action labels to action ids
private int pairprogrampegsigfreidoIndex = 1; // index to be used for labeling multiple actions of the same type
private ArrayList<Integer> pairprogrampegsigfreidoIndices = new ArrayList<Integer>(); // an ArrayList to map indices for PairProgramPegSigfreido Action labels to action ids
private int unittestingandfixingIndex = 1; // index to be used for labeling multiple actions of the same type
private ArrayList<Integer> unittestingandfixingIndices = new ArrayList<Integer>(); // an ArrayList to map indices for UnitTestingAndFixing Action labels to action ids
private int refactorIndex = 1; // index to be used for labeling multiple actions of the same type
private ArrayList<Integer> refactorIndices = new ArrayList<Integer>(); // an ArrayList to map indices for Refactor Action labels to action ids
private int integraterobertjoyceIndex = 1; // index to be used for labeling multiple actions of the same type
private ArrayList<Integer> integraterobertjoyceIndices = new ArrayList<Integer>(); // an ArrayList to map indices for IntegrateRobertJoyce Action labels to action ids
private int integratetimothyredaIndex = 1; // index to be used for labeling multiple actions of the same type
private ArrayList<Integer> integratetimothyredaIndices = new ArrayList<Integer>(); // an ArrayList to map indices for IntegrateTimothyReda Action labels to action ids
private int integratepegsigfreidoIndex = 1; // index to be used for labeling multiple actions of the same type
private ArrayList<Integer> integratepegsigfreidoIndices = new ArrayList<Integer>(); // an ArrayList to map indices for IntegratePegSigfreido Action labels to action ids
private int integrateIndex = 1; // index to be used for labeling multiple actions of the same type
private ArrayList<Integer> integrateIndices = new ArrayList<Integer>(); // an ArrayList to map indices for Integrate Action labels to action ids
private int acceptancetestingIndex = 1; // index to be used for labeling multiple actions of the same type
private ArrayList<Integer> acceptancetestingIndices = new ArrayList<Integer>(); // an ArrayList to map indices for AcceptanceTesting Action labels to action ids
private int releasecodeandenditerationIndex = 1; // index to be used for labeling multiple actions of the same type
private ArrayList<Integer> releasecodeandenditerationIndices = new ArrayList<Integer>(); // an ArrayList to map indices for ReleaseCodeAndEndIteration Action labels to action ids
private int requirereleaseplandooverIndex = 1; // index to be used for labeling multiple actions of the same type
private ArrayList<Integer> requirereleaseplandooverIndices = new ArrayList<Integer>(); // an ArrayList to map indices for RequireReleasePlanDoOver Action labels to action ids
private int customercomplainsIndex = 1; // index to be used for labeling multiple actions of the same type
private ArrayList<Integer> customercomplainsIndices = new ArrayList<Integer>(); // an ArrayList to map indices for CustomerComplains Action labels to action ids
private int allemployeesidleIndex = 1; // index to be used for labeling multiple actions of the same type
private ArrayList<Integer> allemployeesidleIndices = new ArrayList<Integer>(); // an ArrayList to map indices for AllEmployeesIdle Action labels to action ids
private int deliverfinalproducttocustomerIndex = 1; // index to be used for labeling multiple actions of the same type
private ArrayList<Integer> deliverfinalproducttocustomerIndices = new ArrayList<Integer>(); // an ArrayList to map indices for DeliverFinalProductToCustomer Action labels to action ids
private int gameoverIndex = 1; // index to be used for labeling multiple actions of the same type
private ArrayList<Integer> gameoverIndices = new ArrayList<Integer>(); // an ArrayList to map indices for GameOver Action labels to action ids

public ActionGraph(ArrayList<State> log, String[] actionNames, boolean showChart, Branch branch) {
super();
String title = "Action Graph";
if (branch.getName() != null) {
title = title.concat(" - " + branch.getName());
}
setTitle(title);
this.log = log;
this.actionNames = actionNames;
lastRightClickedX = 0;

// add dummy entries for 0 positions (since we don't want to display a series on the 0 line):
createuserstoriesIndices.add(0, new Integer(-1));
releaseplanningmeetingIndices.add(0, new Integer(-1));
startiterationIndices.add(0, new Integer(-1));
iterationplanningmeetingIndices.add(0, new Integer(-1));
chooseuserstoriesforiterationIndices.add(0, new Integer(-1));
createprogrammingtasksIndices.add(0, new Integer(-1));
createacceptancetestsIndices.add(0, new Integer(-1));
designIndices.add(0, new Integer(-1));
createunittestsIndices.add(0, new Integer(-1));
learncodingstandardIndices.add(0, new Integer(-1));
programIndices.add(0, new Integer(-1));
pairprogramrobertjoyceIndices.add(0, new Integer(-1));
pairprogramtimothyredaIndices.add(0, new Integer(-1));
pairprogrampegsigfreidoIndices.add(0, new Integer(-1));
unittestingandfixingIndices.add(0, new Integer(-1));
refactorIndices.add(0, new Integer(-1));
integraterobertjoyceIndices.add(0, new Integer(-1));
integratetimothyredaIndices.add(0, new Integer(-1));
integratepegsigfreidoIndices.add(0, new Integer(-1));
integrateIndices.add(0, new Integer(-1));
acceptancetestingIndices.add(0, new Integer(-1));
releasecodeandenditerationIndices.add(0, new Integer(-1));
requirereleaseplandooverIndices.add(0, new Integer(-1));
customercomplainsIndices.add(0, new Integer(-1));
allemployeesidleIndices.add(0, new Integer(-1));
deliverfinalproducttocustomerIndices.add(0, new Integer(-1));
gameoverIndices.add(0, new Integer(-1));


// create dataset:
dataset = new XYSeriesCollection();
XYDataset xydataset = createDataset();
chart = createChart(xydataset);
chartPanel = new ChartPanel(chart);
chartPanel.addChartMouseListener(this);
chartPanel.addMouseListener(this);
chartPanel.setPreferredSize(new java.awt.Dimension(500, 270));
setContentPane(chartPanel);
newBranchItem = new JMenuItem("Start new branch from here");
newBranchItem.addActionListener(this);
separator = new JSeparator();
pack();
RefineryUtilities.centerFrameOnScreen(this);
setVisible(showChart);
}

// Creates the dataset for this graph
private XYDataset createDataset() {
// add a dummy entry for index 0:
indices.add(0, "Action");
// go through each action:
for (int i = 0; i < actionNames.length; i++) {
if (actionNames[i].equals("CreateUserStories")) {
// go through the CreateUserStoriesActionStateRepository for each clock tick:
for (int j = 0; j < log.size(); j++) {
State state = log.get(j);
Vector<CreateUserStoriesAction> createuserstoriesActions = state.getActionStateRepository().getCreateUserStoriesActionStateRepository().getAllActions();

// go through each CreateUserStoriesAction:
for (int k = 0; k < createuserstoriesActions.size(); k++) {
CreateUserStoriesAction action = createuserstoriesActions.get(k);

// update series:
updateSeries(action, j);
}
}
}

else if (actionNames[i].equals("ReleasePlanningMeeting")) {
// go through the ReleasePlanningMeetingActionStateRepository for each clock tick:
for (int j = 0; j < log.size(); j++) {
State state = log.get(j);
Vector<ReleasePlanningMeetingAction> releaseplanningmeetingActions = state.getActionStateRepository().getReleasePlanningMeetingActionStateRepository().getAllActions();

// go through each ReleasePlanningMeetingAction:
for (int k = 0; k < releaseplanningmeetingActions.size(); k++) {
ReleasePlanningMeetingAction action = releaseplanningmeetingActions.get(k);

// update series:
updateSeries(action, j);
}
}
}

else if (actionNames[i].equals("StartIteration")) {
// go through the StartIterationActionStateRepository for each clock tick:
for (int j = 0; j < log.size(); j++) {
State state = log.get(j);
Vector<StartIterationAction> startiterationActions = state.getActionStateRepository().getStartIterationActionStateRepository().getAllActions();

// go through each StartIterationAction:
for (int k = 0; k < startiterationActions.size(); k++) {
StartIterationAction action = startiterationActions.get(k);

// update series:
updateSeries(action, j);
}
}
}

else if (actionNames[i].equals("IterationPlanningMeeting")) {
// go through the IterationPlanningMeetingActionStateRepository for each clock tick:
for (int j = 0; j < log.size(); j++) {
State state = log.get(j);
Vector<IterationPlanningMeetingAction> iterationplanningmeetingActions = state.getActionStateRepository().getIterationPlanningMeetingActionStateRepository().getAllActions();

// go through each IterationPlanningMeetingAction:
for (int k = 0; k < iterationplanningmeetingActions.size(); k++) {
IterationPlanningMeetingAction action = iterationplanningmeetingActions.get(k);

// update series:
updateSeries(action, j);
}
}
}

else if (actionNames[i].equals("ChooseUserStoriesForIteration")) {
// go through the ChooseUserStoriesForIterationActionStateRepository for each clock tick:
for (int j = 0; j < log.size(); j++) {
State state = log.get(j);
Vector<ChooseUserStoriesForIterationAction> chooseuserstoriesforiterationActions = state.getActionStateRepository().getChooseUserStoriesForIterationActionStateRepository().getAllActions();

// go through each ChooseUserStoriesForIterationAction:
for (int k = 0; k < chooseuserstoriesforiterationActions.size(); k++) {
ChooseUserStoriesForIterationAction action = chooseuserstoriesforiterationActions.get(k);

// update series:
updateSeries(action, j);
}
}
}

else if (actionNames[i].equals("CreateProgrammingTasks")) {
// go through the CreateProgrammingTasksActionStateRepository for each clock tick:
for (int j = 0; j < log.size(); j++) {
State state = log.get(j);
Vector<CreateProgrammingTasksAction> createprogrammingtasksActions = state.getActionStateRepository().getCreateProgrammingTasksActionStateRepository().getAllActions();

// go through each CreateProgrammingTasksAction:
for (int k = 0; k < createprogrammingtasksActions.size(); k++) {
CreateProgrammingTasksAction action = createprogrammingtasksActions.get(k);

// update series:
updateSeries(action, j);
}
}
}

else if (actionNames[i].equals("CreateAcceptanceTests")) {
// go through the CreateAcceptanceTestsActionStateRepository for each clock tick:
for (int j = 0; j < log.size(); j++) {
State state = log.get(j);
Vector<CreateAcceptanceTestsAction> createacceptancetestsActions = state.getActionStateRepository().getCreateAcceptanceTestsActionStateRepository().getAllActions();

// go through each CreateAcceptanceTestsAction:
for (int k = 0; k < createacceptancetestsActions.size(); k++) {
CreateAcceptanceTestsAction action = createacceptancetestsActions.get(k);

// update series:
updateSeries(action, j);
}
}
}

else if (actionNames[i].equals("Design")) {
// go through the DesignActionStateRepository for each clock tick:
for (int j = 0; j < log.size(); j++) {
State state = log.get(j);
Vector<DesignAction> designActions = state.getActionStateRepository().getDesignActionStateRepository().getAllActions();

// go through each DesignAction:
for (int k = 0; k < designActions.size(); k++) {
DesignAction action = designActions.get(k);

// update series:
updateSeries(action, j);
}
}
}

else if (actionNames[i].equals("CreateUnitTests")) {
// go through the CreateUnitTestsActionStateRepository for each clock tick:
for (int j = 0; j < log.size(); j++) {
State state = log.get(j);
Vector<CreateUnitTestsAction> createunittestsActions = state.getActionStateRepository().getCreateUnitTestsActionStateRepository().getAllActions();

// go through each CreateUnitTestsAction:
for (int k = 0; k < createunittestsActions.size(); k++) {
CreateUnitTestsAction action = createunittestsActions.get(k);

// update series:
updateSeries(action, j);
}
}
}

else if (actionNames[i].equals("LearnCodingStandard")) {
// go through the LearnCodingStandardActionStateRepository for each clock tick:
for (int j = 0; j < log.size(); j++) {
State state = log.get(j);
Vector<LearnCodingStandardAction> learncodingstandardActions = state.getActionStateRepository().getLearnCodingStandardActionStateRepository().getAllActions();

// go through each LearnCodingStandardAction:
for (int k = 0; k < learncodingstandardActions.size(); k++) {
LearnCodingStandardAction action = learncodingstandardActions.get(k);

// update series:
updateSeries(action, j);
}
}
}

else if (actionNames[i].equals("Program")) {
// go through the ProgramActionStateRepository for each clock tick:
for (int j = 0; j < log.size(); j++) {
State state = log.get(j);
Vector<ProgramAction> programActions = state.getActionStateRepository().getProgramActionStateRepository().getAllActions();

// go through each ProgramAction:
for (int k = 0; k < programActions.size(); k++) {
ProgramAction action = programActions.get(k);

// update series:
updateSeries(action, j);
}
}
}

else if (actionNames[i].equals("PairProgramRobertJoyce")) {
// go through the PairProgramRobertJoyceActionStateRepository for each clock tick:
for (int j = 0; j < log.size(); j++) {
State state = log.get(j);
Vector<PairProgramRobertJoyceAction> pairprogramrobertjoyceActions = state.getActionStateRepository().getPairProgramRobertJoyceActionStateRepository().getAllActions();

// go through each PairProgramRobertJoyceAction:
for (int k = 0; k < pairprogramrobertjoyceActions.size(); k++) {
PairProgramRobertJoyceAction action = pairprogramrobertjoyceActions.get(k);

// update series:
updateSeries(action, j);
}
}
}

else if (actionNames[i].equals("PairProgramTimothyReda")) {
// go through the PairProgramTimothyRedaActionStateRepository for each clock tick:
for (int j = 0; j < log.size(); j++) {
State state = log.get(j);
Vector<PairProgramTimothyRedaAction> pairprogramtimothyredaActions = state.getActionStateRepository().getPairProgramTimothyRedaActionStateRepository().getAllActions();

// go through each PairProgramTimothyRedaAction:
for (int k = 0; k < pairprogramtimothyredaActions.size(); k++) {
PairProgramTimothyRedaAction action = pairprogramtimothyredaActions.get(k);

// update series:
updateSeries(action, j);
}
}
}

else if (actionNames[i].equals("PairProgramPegSigfreido")) {
// go through the PairProgramPegSigfreidoActionStateRepository for each clock tick:
for (int j = 0; j < log.size(); j++) {
State state = log.get(j);
Vector<PairProgramPegSigfreidoAction> pairprogrampegsigfreidoActions = state.getActionStateRepository().getPairProgramPegSigfreidoActionStateRepository().getAllActions();

// go through each PairProgramPegSigfreidoAction:
for (int k = 0; k < pairprogrampegsigfreidoActions.size(); k++) {
PairProgramPegSigfreidoAction action = pairprogrampegsigfreidoActions.get(k);

// update series:
updateSeries(action, j);
}
}
}

else if (actionNames[i].equals("UnitTestingAndFixing")) {
// go through the UnitTestingAndFixingActionStateRepository for each clock tick:
for (int j = 0; j < log.size(); j++) {
State state = log.get(j);
Vector<UnitTestingAndFixingAction> unittestingandfixingActions = state.getActionStateRepository().getUnitTestingAndFixingActionStateRepository().getAllActions();

// go through each UnitTestingAndFixingAction:
for (int k = 0; k < unittestingandfixingActions.size(); k++) {
UnitTestingAndFixingAction action = unittestingandfixingActions.get(k);

// update series:
updateSeries(action, j);
}
}
}

else if (actionNames[i].equals("Refactor")) {
// go through the RefactorActionStateRepository for each clock tick:
for (int j = 0; j < log.size(); j++) {
State state = log.get(j);
Vector<RefactorAction> refactorActions = state.getActionStateRepository().getRefactorActionStateRepository().getAllActions();

// go through each RefactorAction:
for (int k = 0; k < refactorActions.size(); k++) {
RefactorAction action = refactorActions.get(k);

// update series:
updateSeries(action, j);
}
}
}

else if (actionNames[i].equals("IntegrateRobertJoyce")) {
// go through the IntegrateRobertJoyceActionStateRepository for each clock tick:
for (int j = 0; j < log.size(); j++) {
State state = log.get(j);
Vector<IntegrateRobertJoyceAction> integraterobertjoyceActions = state.getActionStateRepository().getIntegrateRobertJoyceActionStateRepository().getAllActions();

// go through each IntegrateRobertJoyceAction:
for (int k = 0; k < integraterobertjoyceActions.size(); k++) {
IntegrateRobertJoyceAction action = integraterobertjoyceActions.get(k);

// update series:
updateSeries(action, j);
}
}
}

else if (actionNames[i].equals("IntegrateTimothyReda")) {
// go through the IntegrateTimothyRedaActionStateRepository for each clock tick:
for (int j = 0; j < log.size(); j++) {
State state = log.get(j);
Vector<IntegrateTimothyRedaAction> integratetimothyredaActions = state.getActionStateRepository().getIntegrateTimothyRedaActionStateRepository().getAllActions();

// go through each IntegrateTimothyRedaAction:
for (int k = 0; k < integratetimothyredaActions.size(); k++) {
IntegrateTimothyRedaAction action = integratetimothyredaActions.get(k);

// update series:
updateSeries(action, j);
}
}
}

else if (actionNames[i].equals("IntegratePegSigfreido")) {
// go through the IntegratePegSigfreidoActionStateRepository for each clock tick:
for (int j = 0; j < log.size(); j++) {
State state = log.get(j);
Vector<IntegratePegSigfreidoAction> integratepegsigfreidoActions = state.getActionStateRepository().getIntegratePegSigfreidoActionStateRepository().getAllActions();

// go through each IntegratePegSigfreidoAction:
for (int k = 0; k < integratepegsigfreidoActions.size(); k++) {
IntegratePegSigfreidoAction action = integratepegsigfreidoActions.get(k);

// update series:
updateSeries(action, j);
}
}
}

else if (actionNames[i].equals("Integrate")) {
// go through the IntegrateActionStateRepository for each clock tick:
for (int j = 0; j < log.size(); j++) {
State state = log.get(j);
Vector<IntegrateAction> integrateActions = state.getActionStateRepository().getIntegrateActionStateRepository().getAllActions();

// go through each IntegrateAction:
for (int k = 0; k < integrateActions.size(); k++) {
IntegrateAction action = integrateActions.get(k);

// update series:
updateSeries(action, j);
}
}
}

else if (actionNames[i].equals("AcceptanceTesting")) {
// go through the AcceptanceTestingActionStateRepository for each clock tick:
for (int j = 0; j < log.size(); j++) {
State state = log.get(j);
Vector<AcceptanceTestingAction> acceptancetestingActions = state.getActionStateRepository().getAcceptanceTestingActionStateRepository().getAllActions();

// go through each AcceptanceTestingAction:
for (int k = 0; k < acceptancetestingActions.size(); k++) {
AcceptanceTestingAction action = acceptancetestingActions.get(k);

// update series:
updateSeries(action, j);
}
}
}

else if (actionNames[i].equals("ReleaseCodeAndEndIteration")) {
// go through the ReleaseCodeAndEndIterationActionStateRepository for each clock tick:
for (int j = 0; j < log.size(); j++) {
State state = log.get(j);
Vector<ReleaseCodeAndEndIterationAction> releasecodeandenditerationActions = state.getActionStateRepository().getReleaseCodeAndEndIterationActionStateRepository().getAllActions();

// go through each ReleaseCodeAndEndIterationAction:
for (int k = 0; k < releasecodeandenditerationActions.size(); k++) {
ReleaseCodeAndEndIterationAction action = releasecodeandenditerationActions.get(k);

// update series:
updateSeries(action, j);
}
}
}

else if (actionNames[i].equals("RequireReleasePlanDoOver")) {
// go through the RequireReleasePlanDoOverActionStateRepository for each clock tick:
for (int j = 0; j < log.size(); j++) {
State state = log.get(j);
Vector<RequireReleasePlanDoOverAction> requirereleaseplandooverActions = state.getActionStateRepository().getRequireReleasePlanDoOverActionStateRepository().getAllActions();

// go through each RequireReleasePlanDoOverAction:
for (int k = 0; k < requirereleaseplandooverActions.size(); k++) {
RequireReleasePlanDoOverAction action = requirereleaseplandooverActions.get(k);

// update series:
updateSeries(action, j);
}
}
}

else if (actionNames[i].equals("CustomerComplains")) {
// go through the CustomerComplainsActionStateRepository for each clock tick:
for (int j = 0; j < log.size(); j++) {
State state = log.get(j);
Vector<CustomerComplainsAction> customercomplainsActions = state.getActionStateRepository().getCustomerComplainsActionStateRepository().getAllActions();

// go through each CustomerComplainsAction:
for (int k = 0; k < customercomplainsActions.size(); k++) {
CustomerComplainsAction action = customercomplainsActions.get(k);

// update series:
updateSeries(action, j);
}
}
}

else if (actionNames[i].equals("AllEmployeesIdle")) {
// go through the AllEmployeesIdleActionStateRepository for each clock tick:
for (int j = 0; j < log.size(); j++) {
State state = log.get(j);
Vector<AllEmployeesIdleAction> allemployeesidleActions = state.getActionStateRepository().getAllEmployeesIdleActionStateRepository().getAllActions();

// go through each AllEmployeesIdleAction:
for (int k = 0; k < allemployeesidleActions.size(); k++) {
AllEmployeesIdleAction action = allemployeesidleActions.get(k);

// update series:
updateSeries(action, j);
}
}
}

else if (actionNames[i].equals("DeliverFinalProductToCustomer")) {
// go through the DeliverFinalProductToCustomerActionStateRepository for each clock tick:
for (int j = 0; j < log.size(); j++) {
State state = log.get(j);
Vector<DeliverFinalProductToCustomerAction> deliverfinalproducttocustomerActions = state.getActionStateRepository().getDeliverFinalProductToCustomerActionStateRepository().getAllActions();

// go through each DeliverFinalProductToCustomerAction:
for (int k = 0; k < deliverfinalproducttocustomerActions.size(); k++) {
DeliverFinalProductToCustomerAction action = deliverfinalproducttocustomerActions.get(k);

// update series:
updateSeries(action, j);
}
}
}

else if (actionNames[i].equals("GameOver")) {
// go through the GameOverActionStateRepository for each clock tick:
for (int j = 0; j < log.size(); j++) {
State state = log.get(j);
Vector<GameOverAction> gameoverActions = state.getActionStateRepository().getGameOverActionStateRepository().getAllActions();

// go through each GameOverAction:
for (int k = 0; k < gameoverActions.size(); k++) {
GameOverAction action = gameoverActions.get(k);

// update series:
updateSeries(action, j);
}
}
}

}
return dataset;
}

// Creates the chart for this graph
private JFreeChart createChart(XYDataset dataset) {
// create the chart:
JFreeChart chart = ChartFactory.createXYLineChart("Action Graph", "Clock Ticks", null, dataset, PlotOrientation.VERTICAL, true, true, false);
chart.setBackgroundPaint(Color.WHITE);
XYPlot plot = (XYPlot) chart.getPlot();
plot.getRenderer().setToolTipGenerator(new ActionGraphToolTipGenerator());
plot.setBackgroundPaint(new Color(0xFF, 0xFF, 0xCC));
plot.setAxisOffset(new RectangleInsets(5.0, 5.0, 5.0, 5.0));
plot.setDomainGridlinePaint(Color.BLACK);
plot.setRangeGridlinePaint(Color.BLACK);
ValueAxis rangeAxis = plot.getRangeAxis();
rangeAxis.setTickLabelsVisible(false);
rangeAxis.setTickMarksVisible(false);
rangeAxis.setAxisLineVisible(false);
rangeAxis.setStandardTickUnits(NumberAxis.createIntegerTickUnits());
plot.getDomainAxis().setStandardTickUnits(NumberAxis.createIntegerTickUnits());
XYLineAndShapeRenderer renderer = (XYLineAndShapeRenderer)plot.getRenderer();
renderer.setShapesVisible(true);
renderer.setShapesFilled(true);

// change the auto tick unit selection to integer units only:
NumberAxis domainAxis = (NumberAxis) plot.getDomainAxis();
domainAxis.setStandardTickUnits(NumberAxis.createIntegerTickUnits());

return chart;
}

private void updateSeries(simse.adts.actions.Action action, int clockTick) {
// if a series has not been created for this action, create one:
if (!series.containsKey(new Integer(action.getId()))) {
XYSeries newSeries = null;
String newSeriesName = "";
if (action instanceof CreateUserStoriesAction) {
newSeriesName = "CreateUserStoriesAction-" + createuserstoriesIndex;
newSeries = new XYSeries(newSeriesName);
createuserstoriesIndices.add(createuserstoriesIndex, new Integer(action.getId()));
createuserstoriesIndex++;
}
else if (action instanceof ReleasePlanningMeetingAction) {
newSeriesName = "ReleasePlanningMeetingAction-" + releaseplanningmeetingIndex;
newSeries = new XYSeries(newSeriesName);
releaseplanningmeetingIndices.add(releaseplanningmeetingIndex, new Integer(action.getId()));
releaseplanningmeetingIndex++;
}
else if (action instanceof StartIterationAction) {
newSeriesName = "StartIterationAction-" + startiterationIndex;
newSeries = new XYSeries(newSeriesName);
startiterationIndices.add(startiterationIndex, new Integer(action.getId()));
startiterationIndex++;
}
else if (action instanceof IterationPlanningMeetingAction) {
newSeriesName = "IterationPlanningMeetingAction-" + iterationplanningmeetingIndex;
newSeries = new XYSeries(newSeriesName);
iterationplanningmeetingIndices.add(iterationplanningmeetingIndex, new Integer(action.getId()));
iterationplanningmeetingIndex++;
}
else if (action instanceof ChooseUserStoriesForIterationAction) {
newSeriesName = "ChooseUserStoriesForIterationAction-" + chooseuserstoriesforiterationIndex;
newSeries = new XYSeries(newSeriesName);
chooseuserstoriesforiterationIndices.add(chooseuserstoriesforiterationIndex, new Integer(action.getId()));
chooseuserstoriesforiterationIndex++;
}
else if (action instanceof CreateProgrammingTasksAction) {
newSeriesName = "CreateProgrammingTasksAction-" + createprogrammingtasksIndex;
newSeries = new XYSeries(newSeriesName);
createprogrammingtasksIndices.add(createprogrammingtasksIndex, new Integer(action.getId()));
createprogrammingtasksIndex++;
}
else if (action instanceof CreateAcceptanceTestsAction) {
newSeriesName = "CreateAcceptanceTestsAction-" + createacceptancetestsIndex;
newSeries = new XYSeries(newSeriesName);
createacceptancetestsIndices.add(createacceptancetestsIndex, new Integer(action.getId()));
createacceptancetestsIndex++;
}
else if (action instanceof DesignAction) {
newSeriesName = "DesignAction-" + designIndex;
newSeries = new XYSeries(newSeriesName);
designIndices.add(designIndex, new Integer(action.getId()));
designIndex++;
}
else if (action instanceof CreateUnitTestsAction) {
newSeriesName = "CreateUnitTestsAction-" + createunittestsIndex;
newSeries = new XYSeries(newSeriesName);
createunittestsIndices.add(createunittestsIndex, new Integer(action.getId()));
createunittestsIndex++;
}
else if (action instanceof LearnCodingStandardAction) {
newSeriesName = "LearnCodingStandardAction-" + learncodingstandardIndex;
newSeries = new XYSeries(newSeriesName);
learncodingstandardIndices.add(learncodingstandardIndex, new Integer(action.getId()));
learncodingstandardIndex++;
}
else if (action instanceof ProgramAction) {
newSeriesName = "ProgramAction-" + programIndex;
newSeries = new XYSeries(newSeriesName);
programIndices.add(programIndex, new Integer(action.getId()));
programIndex++;
}
else if (action instanceof PairProgramRobertJoyceAction) {
newSeriesName = "PairProgramRobertJoyceAction-" + pairprogramrobertjoyceIndex;
newSeries = new XYSeries(newSeriesName);
pairprogramrobertjoyceIndices.add(pairprogramrobertjoyceIndex, new Integer(action.getId()));
pairprogramrobertjoyceIndex++;
}
else if (action instanceof PairProgramTimothyRedaAction) {
newSeriesName = "PairProgramTimothyRedaAction-" + pairprogramtimothyredaIndex;
newSeries = new XYSeries(newSeriesName);
pairprogramtimothyredaIndices.add(pairprogramtimothyredaIndex, new Integer(action.getId()));
pairprogramtimothyredaIndex++;
}
else if (action instanceof PairProgramPegSigfreidoAction) {
newSeriesName = "PairProgramPegSigfreidoAction-" + pairprogrampegsigfreidoIndex;
newSeries = new XYSeries(newSeriesName);
pairprogrampegsigfreidoIndices.add(pairprogrampegsigfreidoIndex, new Integer(action.getId()));
pairprogrampegsigfreidoIndex++;
}
else if (action instanceof UnitTestingAndFixingAction) {
newSeriesName = "UnitTestingAndFixingAction-" + unittestingandfixingIndex;
newSeries = new XYSeries(newSeriesName);
unittestingandfixingIndices.add(unittestingandfixingIndex, new Integer(action.getId()));
unittestingandfixingIndex++;
}
else if (action instanceof RefactorAction) {
newSeriesName = "RefactorAction-" + refactorIndex;
newSeries = new XYSeries(newSeriesName);
refactorIndices.add(refactorIndex, new Integer(action.getId()));
refactorIndex++;
}
else if (action instanceof IntegrateRobertJoyceAction) {
newSeriesName = "IntegrateRobertJoyceAction-" + integraterobertjoyceIndex;
newSeries = new XYSeries(newSeriesName);
integraterobertjoyceIndices.add(integraterobertjoyceIndex, new Integer(action.getId()));
integraterobertjoyceIndex++;
}
else if (action instanceof IntegrateTimothyRedaAction) {
newSeriesName = "IntegrateTimothyRedaAction-" + integratetimothyredaIndex;
newSeries = new XYSeries(newSeriesName);
integratetimothyredaIndices.add(integratetimothyredaIndex, new Integer(action.getId()));
integratetimothyredaIndex++;
}
else if (action instanceof IntegratePegSigfreidoAction) {
newSeriesName = "IntegratePegSigfreidoAction-" + integratepegsigfreidoIndex;
newSeries = new XYSeries(newSeriesName);
integratepegsigfreidoIndices.add(integratepegsigfreidoIndex, new Integer(action.getId()));
integratepegsigfreidoIndex++;
}
else if (action instanceof IntegrateAction) {
newSeriesName = "IntegrateAction-" + integrateIndex;
newSeries = new XYSeries(newSeriesName);
integrateIndices.add(integrateIndex, new Integer(action.getId()));
integrateIndex++;
}
else if (action instanceof AcceptanceTestingAction) {
newSeriesName = "AcceptanceTestingAction-" + acceptancetestingIndex;
newSeries = new XYSeries(newSeriesName);
acceptancetestingIndices.add(acceptancetestingIndex, new Integer(action.getId()));
acceptancetestingIndex++;
}
else if (action instanceof ReleaseCodeAndEndIterationAction) {
newSeriesName = "ReleaseCodeAndEndIterationAction-" + releasecodeandenditerationIndex;
newSeries = new XYSeries(newSeriesName);
releasecodeandenditerationIndices.add(releasecodeandenditerationIndex, new Integer(action.getId()));
releasecodeandenditerationIndex++;
}
else if (action instanceof RequireReleasePlanDoOverAction) {
newSeriesName = "RequireReleasePlanDoOverAction-" + requirereleaseplandooverIndex;
newSeries = new XYSeries(newSeriesName);
requirereleaseplandooverIndices.add(requirereleaseplandooverIndex, new Integer(action.getId()));
requirereleaseplandooverIndex++;
}
else if (action instanceof CustomerComplainsAction) {
newSeriesName = "CustomerComplainsAction-" + customercomplainsIndex;
newSeries = new XYSeries(newSeriesName);
customercomplainsIndices.add(customercomplainsIndex, new Integer(action.getId()));
customercomplainsIndex++;
}
else if (action instanceof AllEmployeesIdleAction) {
newSeriesName = "AllEmployeesIdleAction-" + allemployeesidleIndex;
newSeries = new XYSeries(newSeriesName);
allemployeesidleIndices.add(allemployeesidleIndex, new Integer(action.getId()));
allemployeesidleIndex++;
}
else if (action instanceof DeliverFinalProductToCustomerAction) {
newSeriesName = "DeliverFinalProductToCustomerAction-" + deliverfinalproducttocustomerIndex;
newSeries = new XYSeries(newSeriesName);
deliverfinalproducttocustomerIndices.add(deliverfinalproducttocustomerIndex, new Integer(action.getId()));
deliverfinalproducttocustomerIndex++;
}
else if (action instanceof GameOverAction) {
newSeriesName = "GameOverAction-" + gameoverIndex;
newSeries = new XYSeries(newSeriesName);
gameoverIndices.add(gameoverIndex, new Integer(action.getId()));
gameoverIndex++;
}
// add the data value to the series:
newSeries.add(clockTick, actionIndex);

// add the series to the Hashtable:
series.put(new Integer(action.getId()), newSeries);

// add the index entry to the ArrayList:
indices.add(actionIndex, newSeriesName);
dataset.addSeries(newSeries);

// update the index for the next new action:
actionIndex++;
}
else {
XYSeries oldSeries = series.get(new Integer(action.getId()));
int index = 0;
if (action instanceof CreateUserStoriesAction) {
index = createuserstoriesIndices.indexOf(new Integer(action.getId()));

// add the data value to the series:
oldSeries.add(clockTick, indices.indexOf("CreateUserStoriesAction-" + index));
}
else if (action instanceof ReleasePlanningMeetingAction) {
index = releaseplanningmeetingIndices.indexOf(new Integer(action.getId()));

// add the data value to the series:
oldSeries.add(clockTick, indices.indexOf("ReleasePlanningMeetingAction-" + index));
}
else if (action instanceof StartIterationAction) {
index = startiterationIndices.indexOf(new Integer(action.getId()));

// add the data value to the series:
oldSeries.add(clockTick, indices.indexOf("StartIterationAction-" + index));
}
else if (action instanceof IterationPlanningMeetingAction) {
index = iterationplanningmeetingIndices.indexOf(new Integer(action.getId()));

// add the data value to the series:
oldSeries.add(clockTick, indices.indexOf("IterationPlanningMeetingAction-" + index));
}
else if (action instanceof ChooseUserStoriesForIterationAction) {
index = chooseuserstoriesforiterationIndices.indexOf(new Integer(action.getId()));

// add the data value to the series:
oldSeries.add(clockTick, indices.indexOf("ChooseUserStoriesForIterationAction-" + index));
}
else if (action instanceof CreateProgrammingTasksAction) {
index = createprogrammingtasksIndices.indexOf(new Integer(action.getId()));

// add the data value to the series:
oldSeries.add(clockTick, indices.indexOf("CreateProgrammingTasksAction-" + index));
}
else if (action instanceof CreateAcceptanceTestsAction) {
index = createacceptancetestsIndices.indexOf(new Integer(action.getId()));

// add the data value to the series:
oldSeries.add(clockTick, indices.indexOf("CreateAcceptanceTestsAction-" + index));
}
else if (action instanceof DesignAction) {
index = designIndices.indexOf(new Integer(action.getId()));

// add the data value to the series:
oldSeries.add(clockTick, indices.indexOf("DesignAction-" + index));
}
else if (action instanceof CreateUnitTestsAction) {
index = createunittestsIndices.indexOf(new Integer(action.getId()));

// add the data value to the series:
oldSeries.add(clockTick, indices.indexOf("CreateUnitTestsAction-" + index));
}
else if (action instanceof LearnCodingStandardAction) {
index = learncodingstandardIndices.indexOf(new Integer(action.getId()));

// add the data value to the series:
oldSeries.add(clockTick, indices.indexOf("LearnCodingStandardAction-" + index));
}
else if (action instanceof ProgramAction) {
index = programIndices.indexOf(new Integer(action.getId()));

// add the data value to the series:
oldSeries.add(clockTick, indices.indexOf("ProgramAction-" + index));
}
else if (action instanceof PairProgramRobertJoyceAction) {
index = pairprogramrobertjoyceIndices.indexOf(new Integer(action.getId()));

// add the data value to the series:
oldSeries.add(clockTick, indices.indexOf("PairProgramRobertJoyceAction-" + index));
}
else if (action instanceof PairProgramTimothyRedaAction) {
index = pairprogramtimothyredaIndices.indexOf(new Integer(action.getId()));

// add the data value to the series:
oldSeries.add(clockTick, indices.indexOf("PairProgramTimothyRedaAction-" + index));
}
else if (action instanceof PairProgramPegSigfreidoAction) {
index = pairprogrampegsigfreidoIndices.indexOf(new Integer(action.getId()));

// add the data value to the series:
oldSeries.add(clockTick, indices.indexOf("PairProgramPegSigfreidoAction-" + index));
}
else if (action instanceof UnitTestingAndFixingAction) {
index = unittestingandfixingIndices.indexOf(new Integer(action.getId()));

// add the data value to the series:
oldSeries.add(clockTick, indices.indexOf("UnitTestingAndFixingAction-" + index));
}
else if (action instanceof RefactorAction) {
index = refactorIndices.indexOf(new Integer(action.getId()));

// add the data value to the series:
oldSeries.add(clockTick, indices.indexOf("RefactorAction-" + index));
}
else if (action instanceof IntegrateRobertJoyceAction) {
index = integraterobertjoyceIndices.indexOf(new Integer(action.getId()));

// add the data value to the series:
oldSeries.add(clockTick, indices.indexOf("IntegrateRobertJoyceAction-" + index));
}
else if (action instanceof IntegrateTimothyRedaAction) {
index = integratetimothyredaIndices.indexOf(new Integer(action.getId()));

// add the data value to the series:
oldSeries.add(clockTick, indices.indexOf("IntegrateTimothyRedaAction-" + index));
}
else if (action instanceof IntegratePegSigfreidoAction) {
index = integratepegsigfreidoIndices.indexOf(new Integer(action.getId()));

// add the data value to the series:
oldSeries.add(clockTick, indices.indexOf("IntegratePegSigfreidoAction-" + index));
}
else if (action instanceof IntegrateAction) {
index = integrateIndices.indexOf(new Integer(action.getId()));

// add the data value to the series:
oldSeries.add(clockTick, indices.indexOf("IntegrateAction-" + index));
}
else if (action instanceof AcceptanceTestingAction) {
index = acceptancetestingIndices.indexOf(new Integer(action.getId()));

// add the data value to the series:
oldSeries.add(clockTick, indices.indexOf("AcceptanceTestingAction-" + index));
}
else if (action instanceof ReleaseCodeAndEndIterationAction) {
index = releasecodeandenditerationIndices.indexOf(new Integer(action.getId()));

// add the data value to the series:
oldSeries.add(clockTick, indices.indexOf("ReleaseCodeAndEndIterationAction-" + index));
}
else if (action instanceof RequireReleasePlanDoOverAction) {
index = requirereleaseplandooverIndices.indexOf(new Integer(action.getId()));

// add the data value to the series:
oldSeries.add(clockTick, indices.indexOf("RequireReleasePlanDoOverAction-" + index));
}
else if (action instanceof CustomerComplainsAction) {
index = customercomplainsIndices.indexOf(new Integer(action.getId()));

// add the data value to the series:
oldSeries.add(clockTick, indices.indexOf("CustomerComplainsAction-" + index));
}
else if (action instanceof AllEmployeesIdleAction) {
index = allemployeesidleIndices.indexOf(new Integer(action.getId()));

// add the data value to the series:
oldSeries.add(clockTick, indices.indexOf("AllEmployeesIdleAction-" + index));
}
else if (action instanceof DeliverFinalProductToCustomerAction) {
index = deliverfinalproducttocustomerIndices.indexOf(new Integer(action.getId()));

// add the data value to the series:
oldSeries.add(clockTick, indices.indexOf("DeliverFinalProductToCustomerAction-" + index));
}
else if (action instanceof GameOverAction) {
index = gameoverIndices.indexOf(new Integer(action.getId()));

// add the data value to the series:
oldSeries.add(clockTick, indices.indexOf("GameOverAction-" + index));
}
}
}

// responds to LEFT mouse clicks on the chart
public void chartMouseClicked(ChartMouseEvent event) {
if (event.getTrigger().getButton() == MouseEvent.BUTTON1) { // left-click
ChartEntity entity = event.getEntity();
if ((entity != null) && (entity instanceof XYItemEntity)) {
XYItemEntity xyEntity = (XYItemEntity) entity;

// get the x-value of the action (clock tick):
int xVal = (int) xyEntity.getDataset().getXValue(xyEntity.getSeriesIndex(), xyEntity.getItem());

// get the y-value of the action (action index):
int yVal = (int) xyEntity.getDataset().getYValue(xyEntity.getSeriesIndex(), xyEntity.getItem());

// get the series name of the action:
String seriesName = indices.get(yVal);

// get the action id:
int actionId = getIdOfActionWithSeriesName(seriesName);

if (actionId > -1) { // valid action
Action action = log.get(xVal).getActionStateRepository().getActionWithId(actionId);
if (action != null) {// bring up ActionInfo window:
new ActionInfoWindow(this, seriesName, action, xVal);
}
}
}
}
}

public void chartMouseMoved(ChartMouseEvent event) {}

// responds to RIGHT-clicks on the chart
public void mouseReleased(MouseEvent me) {
if (me.getButton() != MouseEvent.BUTTON1) { // not left-click
XYPlot plot = chart.getXYPlot();
Range domainRange = plot.getDataRange(plot.getDomainAxis());
if (domainRange != null) { // chart is not blank
Point2D pt = chartPanel.translateScreenToJava2D(new Point(me.getX(), me.getY()));
ChartRenderingInfo info = this.chartPanel.getChartRenderingInfo();
Rectangle2D dataArea = info.getPlotInfo().getDataArea();
NumberAxis domainAxis = (NumberAxis)plot.getDomainAxis();
RectangleEdge domainAxisEdge = plot.getDomainAxisEdge();
double chartX = domainAxis.java2DToValue(pt.getX(), dataArea, domainAxisEdge);
lastRightClickedX = (int)Math.rint(chartX);
if (domainRange != null && lastRightClickedX >= domainRange.getLowerBound() && lastRightClickedX <= domainRange.getUpperBound()) { // clicked within domain range
if (chartPanel.getPopupMenu().getComponentIndex(newBranchItem) == -1) { // no new branch item on menu currently
chartPanel.getPopupMenu().add(separator);
chartPanel.getPopupMenu().add(newBranchItem);
chartPanel.getPopupMenu().pack();
chartPanel.getPopupMenu().repaint();
}
}
else { // clicked outside of domain range
if (chartPanel.getPopupMenu().getComponentIndex(newBranchItem) >= 0) { // new branch item currently on menu
chartPanel.getPopupMenu().remove(newBranchItem);
if (chartPanel.getPopupMenu().getComponentIndex(separator) >= 0) { // has separator
chartPanel.getPopupMenu().remove(separator);
}
chartPanel.getPopupMenu().pack();
chartPanel.getPopupMenu().repaint();
}
}
}
}
}

public void mousePressed(MouseEvent me) {}

public void mouseClicked(MouseEvent me) {}

public void mouseEntered(MouseEvent me) {}

public void mouseExited(MouseEvent me) {}

public void actionPerformed(ActionEvent e) {
if (e.getSource() == newBranchItem) {
String newBranchName = JOptionPane.showInputDialog(null, "Please name this new game:", "Name New Game",  JOptionPane.QUESTION_MESSAGE);
if (newBranchName != null) {
State tempState = (State) log.get(lastRightClickedX).clone();
Logger tempLogger = new Logger(tempState, new ArrayList<State>(log.subList(0, lastRightClickedX)));
Clock tempClock = new Clock(tempLogger, lastRightClickedX);
tempState.setClock(tempClock);
tempState.setLogger(tempLogger);
SimSE.startNewBranch(tempState, new Branch(newBranchName, lastRightClickedX, tempClock.getTime(), branch, null));
}
}
}

// returns the id of the action that corresponds to the given series name
private int getIdOfActionWithSeriesName(String seriesName) {
Enumeration<Integer> keys = series.keys();
while (keys.hasMoreElements()) {
Integer id = keys.nextElement();
XYSeries xys = series.get(id);
if (xys.getKey().equals(seriesName)) {
return id.intValue();
}
}
return -1;
}

public void update() {
if ((log.size() > 0) && (log.get(log.size() - 1) != null)) { // there is a log that has not been graphed yet
// add a new end data point for each series:
// go through each action:
for (int i = 0; i < actionNames.length; i++) {
if (actionNames[i].equals("CreateUserStories")) {
// get the CreateUserStoriesActionStateRepository for the last clock tick:
State state = log.get(log.size() - 1);
Vector<CreateUserStoriesAction> createuserstoriesActions = state.getActionStateRepository().getCreateUserStoriesActionStateRepository().getAllActions();

// go through each CreateUserStoriesAction:
for (int k = 0; k < createuserstoriesActions.size(); k++) {
CreateUserStoriesAction action = createuserstoriesActions.get(k);

// update series:
updateSeries(action, (log.size() - 1));
}
}
else if (actionNames[i].equals("ReleasePlanningMeeting")) {
// get the ReleasePlanningMeetingActionStateRepository for the last clock tick:
State state = log.get(log.size() - 1);
Vector<ReleasePlanningMeetingAction> releaseplanningmeetingActions = state.getActionStateRepository().getReleasePlanningMeetingActionStateRepository().getAllActions();

// go through each ReleasePlanningMeetingAction:
for (int k = 0; k < releaseplanningmeetingActions.size(); k++) {
ReleasePlanningMeetingAction action = releaseplanningmeetingActions.get(k);

// update series:
updateSeries(action, (log.size() - 1));
}
}
else if (actionNames[i].equals("StartIteration")) {
// get the StartIterationActionStateRepository for the last clock tick:
State state = log.get(log.size() - 1);
Vector<StartIterationAction> startiterationActions = state.getActionStateRepository().getStartIterationActionStateRepository().getAllActions();

// go through each StartIterationAction:
for (int k = 0; k < startiterationActions.size(); k++) {
StartIterationAction action = startiterationActions.get(k);

// update series:
updateSeries(action, (log.size() - 1));
}
}
else if (actionNames[i].equals("IterationPlanningMeeting")) {
// get the IterationPlanningMeetingActionStateRepository for the last clock tick:
State state = log.get(log.size() - 1);
Vector<IterationPlanningMeetingAction> iterationplanningmeetingActions = state.getActionStateRepository().getIterationPlanningMeetingActionStateRepository().getAllActions();

// go through each IterationPlanningMeetingAction:
for (int k = 0; k < iterationplanningmeetingActions.size(); k++) {
IterationPlanningMeetingAction action = iterationplanningmeetingActions.get(k);

// update series:
updateSeries(action, (log.size() - 1));
}
}
else if (actionNames[i].equals("ChooseUserStoriesForIteration")) {
// get the ChooseUserStoriesForIterationActionStateRepository for the last clock tick:
State state = log.get(log.size() - 1);
Vector<ChooseUserStoriesForIterationAction> chooseuserstoriesforiterationActions = state.getActionStateRepository().getChooseUserStoriesForIterationActionStateRepository().getAllActions();

// go through each ChooseUserStoriesForIterationAction:
for (int k = 0; k < chooseuserstoriesforiterationActions.size(); k++) {
ChooseUserStoriesForIterationAction action = chooseuserstoriesforiterationActions.get(k);

// update series:
updateSeries(action, (log.size() - 1));
}
}
else if (actionNames[i].equals("CreateProgrammingTasks")) {
// get the CreateProgrammingTasksActionStateRepository for the last clock tick:
State state = log.get(log.size() - 1);
Vector<CreateProgrammingTasksAction> createprogrammingtasksActions = state.getActionStateRepository().getCreateProgrammingTasksActionStateRepository().getAllActions();

// go through each CreateProgrammingTasksAction:
for (int k = 0; k < createprogrammingtasksActions.size(); k++) {
CreateProgrammingTasksAction action = createprogrammingtasksActions.get(k);

// update series:
updateSeries(action, (log.size() - 1));
}
}
else if (actionNames[i].equals("CreateAcceptanceTests")) {
// get the CreateAcceptanceTestsActionStateRepository for the last clock tick:
State state = log.get(log.size() - 1);
Vector<CreateAcceptanceTestsAction> createacceptancetestsActions = state.getActionStateRepository().getCreateAcceptanceTestsActionStateRepository().getAllActions();

// go through each CreateAcceptanceTestsAction:
for (int k = 0; k < createacceptancetestsActions.size(); k++) {
CreateAcceptanceTestsAction action = createacceptancetestsActions.get(k);

// update series:
updateSeries(action, (log.size() - 1));
}
}
else if (actionNames[i].equals("Design")) {
// get the DesignActionStateRepository for the last clock tick:
State state = log.get(log.size() - 1);
Vector<DesignAction> designActions = state.getActionStateRepository().getDesignActionStateRepository().getAllActions();

// go through each DesignAction:
for (int k = 0; k < designActions.size(); k++) {
DesignAction action = designActions.get(k);

// update series:
updateSeries(action, (log.size() - 1));
}
}
else if (actionNames[i].equals("CreateUnitTests")) {
// get the CreateUnitTestsActionStateRepository for the last clock tick:
State state = log.get(log.size() - 1);
Vector<CreateUnitTestsAction> createunittestsActions = state.getActionStateRepository().getCreateUnitTestsActionStateRepository().getAllActions();

// go through each CreateUnitTestsAction:
for (int k = 0; k < createunittestsActions.size(); k++) {
CreateUnitTestsAction action = createunittestsActions.get(k);

// update series:
updateSeries(action, (log.size() - 1));
}
}
else if (actionNames[i].equals("LearnCodingStandard")) {
// get the LearnCodingStandardActionStateRepository for the last clock tick:
State state = log.get(log.size() - 1);
Vector<LearnCodingStandardAction> learncodingstandardActions = state.getActionStateRepository().getLearnCodingStandardActionStateRepository().getAllActions();

// go through each LearnCodingStandardAction:
for (int k = 0; k < learncodingstandardActions.size(); k++) {
LearnCodingStandardAction action = learncodingstandardActions.get(k);

// update series:
updateSeries(action, (log.size() - 1));
}
}
else if (actionNames[i].equals("Program")) {
// get the ProgramActionStateRepository for the last clock tick:
State state = log.get(log.size() - 1);
Vector<ProgramAction> programActions = state.getActionStateRepository().getProgramActionStateRepository().getAllActions();

// go through each ProgramAction:
for (int k = 0; k < programActions.size(); k++) {
ProgramAction action = programActions.get(k);

// update series:
updateSeries(action, (log.size() - 1));
}
}
else if (actionNames[i].equals("PairProgramRobertJoyce")) {
// get the PairProgramRobertJoyceActionStateRepository for the last clock tick:
State state = log.get(log.size() - 1);
Vector<PairProgramRobertJoyceAction> pairprogramrobertjoyceActions = state.getActionStateRepository().getPairProgramRobertJoyceActionStateRepository().getAllActions();

// go through each PairProgramRobertJoyceAction:
for (int k = 0; k < pairprogramrobertjoyceActions.size(); k++) {
PairProgramRobertJoyceAction action = pairprogramrobertjoyceActions.get(k);

// update series:
updateSeries(action, (log.size() - 1));
}
}
else if (actionNames[i].equals("PairProgramTimothyReda")) {
// get the PairProgramTimothyRedaActionStateRepository for the last clock tick:
State state = log.get(log.size() - 1);
Vector<PairProgramTimothyRedaAction> pairprogramtimothyredaActions = state.getActionStateRepository().getPairProgramTimothyRedaActionStateRepository().getAllActions();

// go through each PairProgramTimothyRedaAction:
for (int k = 0; k < pairprogramtimothyredaActions.size(); k++) {
PairProgramTimothyRedaAction action = pairprogramtimothyredaActions.get(k);

// update series:
updateSeries(action, (log.size() - 1));
}
}
else if (actionNames[i].equals("PairProgramPegSigfreido")) {
// get the PairProgramPegSigfreidoActionStateRepository for the last clock tick:
State state = log.get(log.size() - 1);
Vector<PairProgramPegSigfreidoAction> pairprogrampegsigfreidoActions = state.getActionStateRepository().getPairProgramPegSigfreidoActionStateRepository().getAllActions();

// go through each PairProgramPegSigfreidoAction:
for (int k = 0; k < pairprogrampegsigfreidoActions.size(); k++) {
PairProgramPegSigfreidoAction action = pairprogrampegsigfreidoActions.get(k);

// update series:
updateSeries(action, (log.size() - 1));
}
}
else if (actionNames[i].equals("UnitTestingAndFixing")) {
// get the UnitTestingAndFixingActionStateRepository for the last clock tick:
State state = log.get(log.size() - 1);
Vector<UnitTestingAndFixingAction> unittestingandfixingActions = state.getActionStateRepository().getUnitTestingAndFixingActionStateRepository().getAllActions();

// go through each UnitTestingAndFixingAction:
for (int k = 0; k < unittestingandfixingActions.size(); k++) {
UnitTestingAndFixingAction action = unittestingandfixingActions.get(k);

// update series:
updateSeries(action, (log.size() - 1));
}
}
else if (actionNames[i].equals("Refactor")) {
// get the RefactorActionStateRepository for the last clock tick:
State state = log.get(log.size() - 1);
Vector<RefactorAction> refactorActions = state.getActionStateRepository().getRefactorActionStateRepository().getAllActions();

// go through each RefactorAction:
for (int k = 0; k < refactorActions.size(); k++) {
RefactorAction action = refactorActions.get(k);

// update series:
updateSeries(action, (log.size() - 1));
}
}
else if (actionNames[i].equals("IntegrateRobertJoyce")) {
// get the IntegrateRobertJoyceActionStateRepository for the last clock tick:
State state = log.get(log.size() - 1);
Vector<IntegrateRobertJoyceAction> integraterobertjoyceActions = state.getActionStateRepository().getIntegrateRobertJoyceActionStateRepository().getAllActions();

// go through each IntegrateRobertJoyceAction:
for (int k = 0; k < integraterobertjoyceActions.size(); k++) {
IntegrateRobertJoyceAction action = integraterobertjoyceActions.get(k);

// update series:
updateSeries(action, (log.size() - 1));
}
}
else if (actionNames[i].equals("IntegrateTimothyReda")) {
// get the IntegrateTimothyRedaActionStateRepository for the last clock tick:
State state = log.get(log.size() - 1);
Vector<IntegrateTimothyRedaAction> integratetimothyredaActions = state.getActionStateRepository().getIntegrateTimothyRedaActionStateRepository().getAllActions();

// go through each IntegrateTimothyRedaAction:
for (int k = 0; k < integratetimothyredaActions.size(); k++) {
IntegrateTimothyRedaAction action = integratetimothyredaActions.get(k);

// update series:
updateSeries(action, (log.size() - 1));
}
}
else if (actionNames[i].equals("IntegratePegSigfreido")) {
// get the IntegratePegSigfreidoActionStateRepository for the last clock tick:
State state = log.get(log.size() - 1);
Vector<IntegratePegSigfreidoAction> integratepegsigfreidoActions = state.getActionStateRepository().getIntegratePegSigfreidoActionStateRepository().getAllActions();

// go through each IntegratePegSigfreidoAction:
for (int k = 0; k < integratepegsigfreidoActions.size(); k++) {
IntegratePegSigfreidoAction action = integratepegsigfreidoActions.get(k);

// update series:
updateSeries(action, (log.size() - 1));
}
}
else if (actionNames[i].equals("Integrate")) {
// get the IntegrateActionStateRepository for the last clock tick:
State state = log.get(log.size() - 1);
Vector<IntegrateAction> integrateActions = state.getActionStateRepository().getIntegrateActionStateRepository().getAllActions();

// go through each IntegrateAction:
for (int k = 0; k < integrateActions.size(); k++) {
IntegrateAction action = integrateActions.get(k);

// update series:
updateSeries(action, (log.size() - 1));
}
}
else if (actionNames[i].equals("AcceptanceTesting")) {
// get the AcceptanceTestingActionStateRepository for the last clock tick:
State state = log.get(log.size() - 1);
Vector<AcceptanceTestingAction> acceptancetestingActions = state.getActionStateRepository().getAcceptanceTestingActionStateRepository().getAllActions();

// go through each AcceptanceTestingAction:
for (int k = 0; k < acceptancetestingActions.size(); k++) {
AcceptanceTestingAction action = acceptancetestingActions.get(k);

// update series:
updateSeries(action, (log.size() - 1));
}
}
else if (actionNames[i].equals("ReleaseCodeAndEndIteration")) {
// get the ReleaseCodeAndEndIterationActionStateRepository for the last clock tick:
State state = log.get(log.size() - 1);
Vector<ReleaseCodeAndEndIterationAction> releasecodeandenditerationActions = state.getActionStateRepository().getReleaseCodeAndEndIterationActionStateRepository().getAllActions();

// go through each ReleaseCodeAndEndIterationAction:
for (int k = 0; k < releasecodeandenditerationActions.size(); k++) {
ReleaseCodeAndEndIterationAction action = releasecodeandenditerationActions.get(k);

// update series:
updateSeries(action, (log.size() - 1));
}
}
else if (actionNames[i].equals("RequireReleasePlanDoOver")) {
// get the RequireReleasePlanDoOverActionStateRepository for the last clock tick:
State state = log.get(log.size() - 1);
Vector<RequireReleasePlanDoOverAction> requirereleaseplandooverActions = state.getActionStateRepository().getRequireReleasePlanDoOverActionStateRepository().getAllActions();

// go through each RequireReleasePlanDoOverAction:
for (int k = 0; k < requirereleaseplandooverActions.size(); k++) {
RequireReleasePlanDoOverAction action = requirereleaseplandooverActions.get(k);

// update series:
updateSeries(action, (log.size() - 1));
}
}
else if (actionNames[i].equals("CustomerComplains")) {
// get the CustomerComplainsActionStateRepository for the last clock tick:
State state = log.get(log.size() - 1);
Vector<CustomerComplainsAction> customercomplainsActions = state.getActionStateRepository().getCustomerComplainsActionStateRepository().getAllActions();

// go through each CustomerComplainsAction:
for (int k = 0; k < customercomplainsActions.size(); k++) {
CustomerComplainsAction action = customercomplainsActions.get(k);

// update series:
updateSeries(action, (log.size() - 1));
}
}
else if (actionNames[i].equals("AllEmployeesIdle")) {
// get the AllEmployeesIdleActionStateRepository for the last clock tick:
State state = log.get(log.size() - 1);
Vector<AllEmployeesIdleAction> allemployeesidleActions = state.getActionStateRepository().getAllEmployeesIdleActionStateRepository().getAllActions();

// go through each AllEmployeesIdleAction:
for (int k = 0; k < allemployeesidleActions.size(); k++) {
AllEmployeesIdleAction action = allemployeesidleActions.get(k);

// update series:
updateSeries(action, (log.size() - 1));
}
}
else if (actionNames[i].equals("DeliverFinalProductToCustomer")) {
// get the DeliverFinalProductToCustomerActionStateRepository for the last clock tick:
State state = log.get(log.size() - 1);
Vector<DeliverFinalProductToCustomerAction> deliverfinalproducttocustomerActions = state.getActionStateRepository().getDeliverFinalProductToCustomerActionStateRepository().getAllActions();

// go through each DeliverFinalProductToCustomerAction:
for (int k = 0; k < deliverfinalproducttocustomerActions.size(); k++) {
DeliverFinalProductToCustomerAction action = deliverfinalproducttocustomerActions.get(k);

// update series:
updateSeries(action, (log.size() - 1));
}
}
else if (actionNames[i].equals("GameOver")) {
// get the GameOverActionStateRepository for the last clock tick:
State state = log.get(log.size() - 1);
Vector<GameOverAction> gameoverActions = state.getActionStateRepository().getGameOverActionStateRepository().getAllActions();

// go through each GameOverAction:
for (int k = 0; k < gameoverActions.size(); k++) {
GameOverAction action = gameoverActions.get(k);

// update series:
updateSeries(action, (log.size() - 1));
}
}
}
}
}

public XYPlot getXYPlot() {
return chart.getXYPlot();
}

public class ActionGraphToolTipGenerator extends AbstractXYItemLabelGenerator implements XYToolTipGenerator {

public ActionGraphToolTipGenerator() {
super();
}

public String generateToolTip(XYDataset dataset, int series, int item) {
return new String(dataset.getSeriesKey(series) + ": click for Action info");
}
}
}