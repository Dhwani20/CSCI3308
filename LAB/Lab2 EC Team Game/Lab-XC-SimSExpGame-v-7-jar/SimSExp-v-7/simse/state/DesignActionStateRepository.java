/* File generated by: simse.codegenerator.stategenerator.RepositoryGenerator */
package simse.state;
import simse.adts.objects.*;
import simse.adts.actions.*;
import java.util.*;

public class DesignActionStateRepository implements Cloneable
{
private Vector<DesignAction> actions;

public DesignActionStateRepository()
{
actions = new Vector<DesignAction>();
}

public Object clone() {
try {
DesignActionStateRepository cl = (DesignActionStateRepository) (super.clone());
Vector<DesignAction> clonedActions = new Vector<DesignAction>();
for (int i = 0; i < actions.size(); i++) {
clonedActions.add((DesignAction)actions.elementAt(i).clone());
}
cl.actions = clonedActions;
return cl;
} catch (CloneNotSupportedException c) {
System.out.println(c.getMessage());
}
return null;
}

public boolean add(DesignAction a)
{
if(actions.contains(a) == false)
{
actions.add(a);
return true;
}
return false;
}

public boolean remove(DesignAction a)
{
if(actions.contains(a))
{
actions.remove(a);
return true;
}
return false;
}

public Vector<DesignAction> getAllActions()
{
return actions;
}

public Vector<DesignAction> getAllActions(SSObject a)
{
Vector<DesignAction> all = new Vector<DesignAction>();
for(int i=0; i<actions.size(); i++)
{
DesignAction b = actions.elementAt(i);
Vector<SSObject> parts = b.getAllParticipants();
for(int j=0; j<parts.size(); j++)
{
if(parts.elementAt(j).equals(a))
{
all.add(b);
break;
}
}
}
return all;
}

public Vector<DesignAction> getAllActiveActions(SSObject a)
{
Vector<DesignAction> all = new Vector<DesignAction>();
for(int i=0; i<actions.size(); i++)
{
DesignAction b = actions.elementAt(i);
Vector<SSObject> parts = b.getAllActiveParticipants();
for(int j=0; j<parts.size(); j++)
{
if(parts.elementAt(j).equals(a))
{
all.add(b);
break;
}
}
}
return all;
}

public Vector<DesignAction> getAllInactiveActions(SSObject a)
{
Vector<DesignAction> all = new Vector<DesignAction>();
for(int i=0; i<actions.size(); i++)
{
DesignAction b = actions.elementAt(i);
Vector<SSObject> parts = b.getAllInactiveParticipants();
for(int j=0; j<parts.size(); j++)
{
if(parts.elementAt(j).equals(a))
{
all.add(b);
break;
}
}
}
return all;
}

public DesignAction getActionWithId(int id) {
for (int i = 0; i < actions.size(); i++) {
DesignAction act = actions.get(i);
if (act.getId() == id) {
return act;
}
}
return null;
}

/*
* Replaces all the participants in each action with their equivalent objects
* in the current state. Calling this function solves the problem that
* happens when you clone actions -- their hashtables point to participant
* objects that were part of the previous, non-cloned state.
* Hence, this function should be called after this object is cloned.
*/
public void refetchParticipants(ArtifactStateRepository artifactRep, CustomerStateRepository customerRep, EmployeeStateRepository employeeRep, ProjectStateRepository projectRep, ToolStateRepository toolRep) {
for (int i = 0; i < actions.size(); i++) {
DesignAction act = actions.elementAt(i);
act.refetchParticipants(artifactRep, customerRep, employeeRep, projectRep, toolRep);}
}
}